# =============================================================================
# Edge Inference VLM - SQLite Database Module
# =============================================================================
# Provides the DescriptionStore class for persisting LLM-generated screen
# descriptions. Uses SQLite with WAL journal mode for concurrent read access.
# =============================================================================

import json
import logging
import sqlite3
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)


class DescriptionStore:
    """
    SQLite-backed storage for frame descriptions generated by the LLM.

    Creates and manages a `frame_description` table that stores each
    captured frame's UUID, capture timestamp, generated description,
    and inference timing metadata.

    Args:
        db_path: File path for the SQLite database.
    """

    def __init__(self, db_path: str):
        self._db_path = db_path

        logger.info("Connecting to database: %s", db_path)
        self._conn = sqlite3.connect(db_path, check_same_thread=False)
        self._conn.row_factory = sqlite3.Row
        self._conn.execute("PRAGMA journal_mode=WAL;")

        self.create_tables()

    def create_tables(self) -> None:
        """
        Create the frame_description table and indexes if they do not exist.

        Schema:
            id               — Auto-incrementing primary key.
            frame_id         — Unique UUID4 identifying the capture.
            captured_at      — ISO 8601 timestamp of the screen capture.
            description      — LLM-generated text description.
            embedding_shape  — JSON string of the embedding dimensions.
            processing_time_ms — Inference duration in milliseconds.
            created_at       — Record creation timestamp (auto-populated).
        """
        self._conn.executescript(
            """
            CREATE TABLE IF NOT EXISTS frame_description (
                id                 INTEGER PRIMARY KEY AUTOINCREMENT,
                frame_id           TEXT    UNIQUE NOT NULL,
                captured_at        TEXT    NOT NULL,
                description        TEXT    NOT NULL,
                embedding_shape    TEXT,
                processing_time_ms REAL,
                created_at         TEXT    DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
            );

            CREATE INDEX IF NOT EXISTS idx_frame_description_captured_at
                ON frame_description(captured_at);
            """
        )
        self._conn.commit()
        logger.info("Database tables ensured.")

    def store_description(
        self,
        frame_id: str,
        captured_at: str,
        description: str,
        embedding_shape: List[int],
        processing_time_ms: float,
    ) -> int:
        """
        Insert a new frame description record.

        Args:
            frame_id:          UUID4 string for this frame.
            captured_at:       ISO 8601 capture timestamp.
            description:       LLM-generated description text.
            embedding_shape:   List of ints (e.g., [576, 1024]).
            processing_time_ms: Inference time in milliseconds.

        Returns:
            The auto-generated row ID of the inserted record.
        """
        cursor = self._conn.execute(
            """
            INSERT INTO frame_description
                (frame_id, captured_at, description, embedding_shape, processing_time_ms)
            VALUES (?, ?, ?, ?, ?)
            """,
            (
                frame_id,
                captured_at,
                description,
                json.dumps(embedding_shape),
                processing_time_ms,
            ),
        )
        self._conn.commit()

        row_id = cursor.lastrowid
        logger.debug("Stored description for frame %s (row_id=%d)", frame_id, row_id)
        return row_id

    def get_description(self, frame_id: str) -> Optional[Dict]:
        """
        Retrieve a single frame description by its frame_id.

        Args:
            frame_id: The UUID4 string of the frame to look up.

        Returns:
            A dict with the record fields, or None if not found.
        """
        cursor = self._conn.execute(
            "SELECT * FROM frame_description WHERE frame_id = ?",
            (frame_id,),
        )
        row = cursor.fetchone()
        return dict(row) if row else None

    def list_descriptions(self, limit: int = 20, offset: int = 0) -> List[Dict]:
        """
        Retrieve a paginated list of frame descriptions, newest first.

        Args:
            limit:  Maximum number of records to return.
            offset: Number of records to skip (for pagination).

        Returns:
            A list of dicts, each containing one record's fields.
        """
        cursor = self._conn.execute(
            """
            SELECT * FROM frame_description
            ORDER BY captured_at DESC
            LIMIT ? OFFSET ?
            """,
            (limit, offset),
        )
        return [dict(row) for row in cursor.fetchall()]

    def get_count(self) -> int:
        """
        Return the total number of stored descriptions.

        Returns:
            Integer count of all records in frame_description.
        """
        cursor = self._conn.execute("SELECT COUNT(*) FROM frame_description")
        return cursor.fetchone()[0]

    def close(self) -> None:
        """Close the database connection."""
        self._conn.close()
        logger.info("Database connection closed.")
